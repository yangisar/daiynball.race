<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DAYINBALL RACE: LINCOLN EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Rubik+Glitch&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #202020;
            font-family: 'Permanent Marker', cursive, sans-serif;
            touch-action: none;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 40%, #505050 40%, #202020 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            color: #FFD700;
            z-index: 10;
            text-align: center;
        }

        h1 {
            font-family: 'Rubik Glitch', cursive;
            font-size: 5rem;
            margin: 0;
            color: #FFF;
            text-shadow: 5px 5px #000, -2px -2px #FF00FF;
            transform: rotate(-2deg);
            letter-spacing: 4px;
        }

        p {
            font-size: 1.5rem;
            color: #00FF00;
            text-shadow: 1px 1px #000;
        }

        button {
            margin-top: 25px;
            padding: 15px 50px;
            font-size: 2rem;
            font-family: 'Permanent Marker', cursive;
            background-color: #000;
            color: #FFF;
            border: 4px solid #FF00FF;
            cursor: pointer;
            box-shadow: 6px 6px 0px #00FF00;
            transition: all 0.1s;
            text-transform: uppercase;
        }

        button:active {
            transform: translate(3px, 3px);
            box-shadow: 3px 3px 0px #00FF00;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 5;
            font-size: 1.5rem;
            color: #FFF;
            text-shadow: 3px 3px #000;
        }

        .hud-left { color: #00FF00; }
        .hud-right { text-align: right; }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 8;
            display: grid;
            grid-template-columns: 70px 70px 70px;
            grid-template-rows: 70px 70px;
            gap: 10px;
            opacity: 0.7;
        }

        .d-btn {
            width: 70px; height: 70px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #FF00FF;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: white;
        }
        
        .d-btn:active { background: rgba(255, 0, 255, 0.4); }
        
        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        #screen-start { display: flex; }
        #screen-gameover { display: none; }

        @media screen and (orientation: portrait) {
            #portrait-warning { display: flex !important; }
        }
        #portrait-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: black;
            color: white;
            z-index: 100;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>

    <div id="portrait-warning">
        <h1>TURN IT SIDEWAYS</h1>
        <p>Rotate device to Landscape for the full experience</p>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="hud">
            <div class="hud-left">HEALTH: <span id="healthVal">100</span>%</div>
            <div class="hud-right">
                LETTERS: <span id="scoreVal">0</span><br>
                TIME: <span id="timeVal">0</span>s
            </div>
        </div>

        <div id="screen-start" class="overlay">
            <h1>DAYINBALL RACE</h1>
            <p style="color: #FF00FF;">ALMATY NIGHT RIDE</p>
            <p style="font-size: 1rem; color: #ddd;">Collect Letters. Survive the Traffic.</p>
            <button onclick="initGame()">START ENGINE</button>
        </div>

        <div id="screen-gameover" class="overlay">
            <h1>WRECKED</h1>
            <p>Time: <span id="end-time">0</span>s | Letters: <span id="end-score">0</span></p>
            <p style="font-size: 1.2rem; color: #00FF00;">Collected: <span id="end-collection"></span></p>
            <button onclick="resetGame()">RIDE AGAIN</button>
        </div>

        <div id="controls">
            <div class="d-btn" id="btn-up">▲</div>
            <div class="d-btn" id="btn-left">◀</div>
            <div class="d-btn" id="btn-down">▼</div>
            <div class="d-btn" id="btn-right">▶</div>
        </div>
    </div>

    <script>
        /** * AUDIO SYSTEM (Web Audio API)
         * No external files needed. Generates Boom Bap beat and SFX.
         */
        const AudioEngine = {
            ctx: null,
            beatTimer: null,
            isPlaying: false,

            init: function() {
                if(!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },

            playTone: function(freq, type, duration, vol=0.1) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            playNoise: function(duration, vol=0.2) {
                if(!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                noise.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },

            // Sounds
            sfxCrash: function() {
                // Low rumble + noise
                this.playTone(100, 'sawtooth', 0.5, 0.2);
                this.playNoise(0.3, 0.3);
            },
            sfxCollect: function() {
                // High ping
                this.playTone(1200, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(1800, 'sine', 0.1, 0.1), 50);
            },

            // Beat Generation
            kick: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },
            snare: function() {
                if(!this.ctx) return;
                this.playNoise(0.2, 0.15); // Simple noise burst
                this.playTone(200, 'triangle', 0.1, 0.1); // Underlying tone
            },
            hihat: function() {
                this.playNoise(0.05, 0.05);
            },

            startBeat: function() {
                if(this.isPlaying) return;
                this.isPlaying = true;
                let step = 0;
                // 95 BPM roughly
                const tempo = 630; 
                this.beatTimer = setInterval(() => {
                    // Simple Boom Bap Pattern
                    // 1  &  2  &  3  &  4  &
                    // K     S     K  K  S
                    if(step === 0) { this.kick(); this.hihat(); }
                    if(step === 2) { this.snare(); this.hihat(); }
                    if(step === 4) { this.kick(); this.hihat(); }
                    if(step === 5) { this.kick(); } // Ghost kick
                    if(step === 6) { this.snare(); this.hihat(); }
                    if(step === 7) { this.hihat(); }
                    
                    step = (step + 1) % 8;
                }, tempo / 4);
            },
            stopBeat: function() {
                clearInterval(this.beatTimer);
                this.isPlaying = false;
            }
        };

        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'START';
        let frames = 0;
        let gameSpeed = 6; // Started slightly faster
        let score = 0;
        let startTime = 0;
        let collectedLettersString = "";
        
        // Kaz Alphabet
        const kazakhChars = ['А', 'Ә', 'Б', 'В', 'Ғ', 'Д', 'Е', 'Ж', 'З', 'И', 'К', 'Қ', 'Л', 'М', 'Н', 'Ң', 'О', 'Ө', 'П', 'Р', 'С', 'Т', 'У', 'Ұ', 'Ү', 'Ф', 'Х', 'Һ', 'Ш', 'Ы', 'І'];

        // Entities
        const car = {
            x: 50, y: 0, w: 110, h: 45, // Wider for Lincoln
            speed: 6,
            health: 100,
            colorBody: '#000000',
            dy: 0, dx: 0
        };

        let obstacles = [];
        let letters = [];
        let particles = [];
        let roadOffset = 0;
        let mountainOffset = 0;
        let roadY;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            roadY = canvas.height * 0.45;
            car.y = roadY + (canvas.height - roadY)/2 - car.h/2;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Controls ---
        const keys = { w: false, a: false, s: false, d: false };
        const touchBtns = ['btn-up', 'btn-down', 'btn-left', 'btn-right'];
        const keyMap = {'btn-up': 'w', 'btn-down': 's', 'btn-left': 'a', 'btn-right': 'd'};

        window.addEventListener('keydown', e => {
            if(e.key==='ArrowUp'||e.key==='w') keys.w=true;
            if(e.key==='ArrowDown'||e.key==='s') keys.s=true;
            if(e.key==='ArrowLeft'||e.key==='a') keys.a=true;
            if(e.key==='ArrowRight'||e.key==='d') keys.d=true;
        });
        window.addEventListener('keyup', e => {
            if(e.key==='ArrowUp'||e.key==='w') keys.w=false;
            if(e.key==='ArrowDown'||e.key==='s') keys.s=false;
            if(e.key==='ArrowLeft'||e.key==='a') keys.a=false;
            if(e.key==='ArrowRight'||e.key==='d') keys.d=false;
        });

        touchBtns.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[keyMap[id]] = true; });
            el.addEventListener('touchend', (e) => { e.preventDefault(); keys[keyMap[id]] = false; });
            el.addEventListener('mousedown', () => keys[keyMap[id]] = true); // Testing
            el.addEventListener('mouseup', () => keys[keyMap[id]] = false);
        });

        // --- Visuals ---

        function drawSkyline() {
            // Sky Gradient
            ctx.fillStyle = '#1a1a2e'; // Night sky
            ctx.fillRect(0, 0, canvas.width, roadY);
            
            // Moon
            ctx.fillStyle = '#FFFACD';
            ctx.beginPath();
            ctx.arc(canvas.width - 100, 80, 40, 0, Math.PI*2);
            ctx.fill();

            // Mountains (Alatau)
            ctx.fillStyle = '#0f0f1a';
            ctx.beginPath();
            ctx.moveTo(0, roadY);
            for(let i=0; i<=canvas.width+200; i+=30) {
                let x = (i - mountainOffset) % (canvas.width+200);
                if(x<0) x+=(canvas.width+200);
                let h = (Math.sin(i*0.02) * 80) + 100; // Smoother mountains
                ctx.lineTo(x, roadY - h);
            }
            ctx.lineTo(canvas.width, roadY);
            ctx.fill();

            // Kok Tobe stylized
            let tx = (canvas.width * 0.7 - mountainOffset*0.5) % (canvas.width+400);
            if(tx<0) tx+=(canvas.width+400);
            ctx.strokeStyle = '#550055';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(tx, roadY); ctx.lineTo(tx, roadY-200); ctx.stroke();
            ctx.fillStyle = '#FF00FF';
            ctx.beginPath(); ctx.arc(tx, roadY-200, 6, 0, Math.PI*2); ctx.fill();
        }

        function drawRoad() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, roadY, canvas.width, canvas.height - roadY);
            
            // Moving markers
            ctx.fillStyle = '#555';
            let laneH = (canvas.height - roadY) / 4;
            for(let i=1; i<4; i++) {
                let y = roadY + (laneH * i);
                for(let j=0; j<canvas.width; j+=100) {
                    let x = (j - roadOffset) % canvas.width;
                    if(x<0) x += canvas.width;
                    ctx.fillRect(x, y, 60, 4);
                }
            }
        }

        function drawLincoln() {
            const {x, y, w, h} = car;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x + 10, y + h - 5, w - 20, 10);

            // Main Body (Black Boxy)
            ctx.fillStyle = '#000000';
            ctx.fillRect(x, y + h*0.3, w, h*0.7); // Lower body
            ctx.fillRect(x + w*0.2, y, w*0.55, h*0.3); // Roof cabin (Boxy)

            // Windows (Tinted)
            ctx.fillStyle = '#222';
            ctx.fillRect(x + w*0.22, y+2, w*0.25, h*0.25); // Side
            ctx.fillRect(x + w*0.50, y+2, w*0.20, h*0.25); // Rear

            // Graffiti Text "Dayinball"
            ctx.save();
            ctx.translate(x + w/2, y + h*0.75);
            ctx.rotate(-0.05); // Slight tilt
            ctx.font = '14px "Permanent Marker"';
            ctx.fillStyle = '#00FF00'; // Neon Green
            ctx.textAlign = 'center';
            ctx.fillText("DAYINBALL", 0, 0);
            ctx.restore();

            // Wheels (White Walls)
            const wheelY = y + h - 2;
            const drawWheel = (wx) => {
                ctx.fillStyle = '#000'; // Tire
                ctx.beginPath(); ctx.arc(wx, wheelY, 11, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#DDD'; // White wall
                ctx.beginPath(); ctx.arc(wx, wheelY, 7, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#222'; // Rim
                ctx.beginPath(); ctx.arc(wx, wheelY, 4, 0, Math.PI*2); ctx.fill();
            };
            drawWheel(x + 25);
            drawWheel(x + w - 25);

            // Headlight glow
            ctx.fillStyle = 'rgba(255, 255, 200, 0.4)';
            ctx.beginPath();
            ctx.moveTo(x + w, y + h*0.4);
            ctx.lineTo(x + w + 100, y + h*0.2);
            ctx.lineTo(x + w + 100, y + h*0.8);
            ctx.fill();
        }

        function drawParticles() {
            particles.forEach((p, index) => {
                ctx.fillStyle = p.c;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) particles.splice(index, 1);
            });
        }

        function spawnParticles(x, y, color) {
            for(let i=0; i<15; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    c: color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        // --- Core Logic ---

        function update() {
            // Movement
            if (keys.w && car.y > roadY) car.y -= car.speed;
            if (keys.s && car.y < canvas.height - car.h) car.y += car.speed;
            if (keys.a && car.x > 0) car.x -= car.speed;
            if (keys.d && car.x < canvas.width - car.w) car.x += car.speed;

            // World Move
            roadOffset += gameSpeed;
            mountainOffset += gameSpeed * 0.2;
            
            // Difficulty Ramping
            // Cap speed at 15 so it's playable, but starts at 6
            if(gameSpeed < 15) gameSpeed += 0.002; 

            // Spawning Logic (More frequent as speed increases)
            // Base frame gap is 80, minus speed factor
            let spawnRate = Math.max(30, 90 - Math.floor(gameSpeed * 3));
            
            if (frames % spawnRate === 0) {
                // Obstacle
                let h = 40;
                let y = Math.random() * (canvas.height - roadY - h) + roadY;
                obstacles.push({ x: canvas.width, y: y, w: 40, h: 40, active: true });
            }

            if (frames % (spawnRate * 1.5) === 0) {
                // Letter
                let char = kazakhChars[Math.floor(Math.random() * kazakhChars.length)];
                let y = Math.random() * (canvas.height - roadY - 40) + roadY;
                letters.push({ x: canvas.width, y: y, w: 40, h: 40, char: char, active: true });
            }

            // Update Entities
            obstacles.forEach(o => o.x -= gameSpeed);
            letters.forEach(l => l.x -= gameSpeed);

            // Cleanup
            obstacles = obstacles.filter(o => o.x + o.w > -100 && o.active);
            letters = letters.filter(l => l.x + l.w > -100 && l.active);

            checkCollisions();

            // Stats
            document.getElementById('healthVal').innerText = Math.floor(car.health);
            document.getElementById('scoreVal').innerText = score;
            document.getElementById('timeVal').innerText = ((Date.now() - startTime)/1000).toFixed(1);

            frames++;
            if (car.health <= 0) gameOver();
        }

        function checkCollisions() {
            // Obstacles
            obstacles.forEach(obs => {
                if (car.x < obs.x + obs.w && car.x + car.w > obs.x &&
                    car.y < obs.y + obs.h && car.y + car.h > obs.y) {
                    if(obs.active) {
                        car.health -= 20;
                        obs.active = false;
                        AudioEngine.sfxCrash();
                        // Pixel Shards (Orange/Red)
                        spawnParticles(obs.x + obs.w/2, obs.y + obs.h/2, '#FF4500'); 
                    }
                }
            });

            // Letters
            letters.forEach(l => {
                if (car.x < l.x + l.w && car.x + car.w > l.x &&
                    car.y < l.y + l.h && car.y + car.h > l.y) {
                    if(l.active) {
                        score++;
                        collectedLettersString += l.char + " ";
                        l.active = false;
                        AudioEngine.sfxCollect();
                    }
                }
            });
        }

        function drawGame() {
            if(gameState !== 'PLAYING') return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawSkyline();
            drawRoad();

            // Obstacles
            ctx.fillStyle = '#FF4500';
            ctx.strokeStyle = '#000';
            obstacles.forEach(o => {
                ctx.fillRect(o.x, o.y, o.w, o.h);
                ctx.strokeRect(o.x, o.y, o.w, o.h);
                // "Concrete" detail
                ctx.fillStyle='rgba(0,0,0,0.2)';
                ctx.fillRect(o.x+5, o.y+5, o.w-10, o.h-10);
                ctx.fillStyle='#FF4500';
            });

            // Letters
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            letters.forEach(l => {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath(); ctx.arc(l.x+20, l.y+20, 20, 0, Math.PI*2); ctx.fill();
                ctx.stroke();
                ctx.fillStyle = '#000';
                ctx.fillText(l.char, l.x+20, l.y+22);
            });

            drawLincoln();
            drawParticles();

            update();
            requestAnimationFrame(drawGame);
        }

        // --- Game Flow ---

        function initGame() {
            AudioEngine.init(); // Must happen on user interaction
            startGame();
        }

        function startGame() {
            document.getElementById('screen-start').style.display = 'none';
            document.getElementById('screen-gameover').style.display = 'none';
            document.getElementById('controls').style.display = 'grid';
            
            gameState = 'PLAYING';
            score = 0;
            car.health = 100;
            car.x = 50;
            gameSpeed = 6;
            obstacles = [];
            letters = [];
            particles = [];
            collectedLettersString = "";
            startTime = Date.now();
            frames = 0;
            
            AudioEngine.startBeat();
            drawGame();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            AudioEngine.stopBeat();
            document.getElementById('screen-gameover').style.display = 'flex';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('end-time').innerText = ((Date.now() - startTime)/1000).toFixed(1);
            document.getElementById('end-score').innerText = score;
            document.getElementById('end-collection').innerText = collectedLettersString;
        }

        function resetGame() {
            startGame();
        }
    </script>
</body>
</html>
